class Binary_Search_Tree:
  # TODO.I have provided the public method skeletons. You will need
  # to add private methods to support the recursive algorithms
  # discussed in class

  class _BST_Node:
    # TODO The Node class is private. You may add any attributes and
    # methods you need.

    def __init__(self, value):
      self._value = value
      self._leftChild = None
      self._rightChild = None
      self._root = None

    def insert_element(self, value):
      #data = Binary_Search_Tree._BST_Node(value)
      if self._value == value:
        return False
      elif self._value > value:
        if self._leftChild:
          return self._leftChild.insert_element(value)
        else:
          self._leftChild = Binary_Search_Tree._BST_Node (value)
          return True
      else:
        if self._rightChild:
          return self._rightChild.insert_element(value)
        else:
          self._rightChild = Binary_Search_Tree._BST_Node (value)
          return True



    def pre_order(self):
      if self:
        print(str(self._value))
        if self._leftChild:
            self._leftChild.pre_order()
        if self._rightChild:
            self._rightChild.pre_order()

    def post_order(self):
      if self:
        if self._leftChild:
            self._leftChild.post_order()
        if self._rightChild:
            self._rightChild.post_order()
        print(str(self._value))

    def in_order(self):
      if self:
        if self._leftChild:
          self._leftChild.in_order()
        print(str(self._value))
        if self._rightChild:
          self._rightChild.in_order()


  def __init__(self):
    self._root = None
    self._size = 0

  def insert_element(self, value):
    if self._root:
      return self._root.insert_element(value)
    else:
      self._root = Binary_Search_Tree._BST_Node (value)
      return True

  def remove_element(self, value, parent=None):
    if value < self._value:
        if value._left is None:
            return None
                  # node = self._root
                  # while node and node._value != value:
                  #   parent = node
                  # if value < node._value:
                  #   node = node._leftChild
                  # elif value > node._value:
                  # node = node._rightChild

                  # value not found
                  # if node._value != value:
                  # return False

                  # remove node with no children
                  # elif node._leftChild is None and node._rightChild is None:
                  # if data < parent.value:
                  #  parent._leftChild = None
                  # else:
                  # parent._rightChild = None
                  # return True

                  # remove node with left child
                  # elif node._leftChild and node._rightChild is None:
                  # if data < parent.value:
                  #  parent._leftChild = node._leftChild
                  # else:
                  # parent._rightChild = node._leftChild
                  # return True
                  # remove node with right child
                  # elif node._leftChild is None and node._rightChild:
                  # if data < parent.value:
                  #  parent._leftChild = node._rightChild
                  # else:
                  # parent._rightChild = node._rightChild
                  # return True

                  # remove node with two children
                  # else:
                  # delNodeParent = node
                  # delNode = node._rightChild
                  # while delNode._leftChild:
                  # delNodeParent = delNode
                  # delNode = delNode._leftChild
                  # node.value = delNode.value
                  # if delNode._rightChild:
                  # if delNodeParent.value > delNode.value:
                  #  delNodeParent._leftChild = delNode._rightChild
                  # elif delNodeParent.value < delNode.value:
                  # delNodeParent._rightChild = delNode._rightChild
                  # else:
                  # if delNode.value < delNodeParent.value:
                  #  delNodeParent._leftChild = None
                  # else:
                  # delNodeParent._rightChild = None

  #def remove_element(self, value):
      #data = Binary_Search_Tree._BST_Node(value)
      #parent = None
      #node = self._root
      #if self._root is None:
       # return False
      #else:
        #return self._root.remove_element(value)


  def in_order(self):
    print ("In Order")
    self._root.in_order()

  def pre_order(self):
    print ("Pre Order")
    self._root.pre_order()

  def post_order(self):
    print("Post Order")
    self._root.post_order()

  def get_height(self):
    # return an integer that represents the height of the tree.
    # assume that an empty tree has height 0 and a tree with one
    # node has height 1. This method must operate in constant time.
    pass # TODO replace pass with your implementation

  def __str__(self):
    return self.in_order()


if __name__ == '__main__':
  BST =Binary_Search_Tree()
  BST.insert_element(5)
  BST.insert_element(7)
  BST.insert_element(9)
  BST.insert_element(2)
  BST.insert_element(30)
  print (BST.pre_order())
  r = BST.remove_element(2)
  print (BST.post_order())
  print (BST.in_order())
  print (str((r)))
