class Binary_Search_Tree:
    """Base Class representing a Binary Search Tree Structure"""
    # Evaluates
    # TODO.I have provided the public method skeletons. You will need
    # to add private methods to support the recursive algorithms
    # discussed in class

    class _BST_Node:
        """Private class for storing linked nodes with values and references to their siblings"""
        # TODO The Node class is private. You may add any attributes and methods you need.

        def __init__(self, value):
            """Node Constructor with 3 attributes"""
            self._value = value     # value being added
            self._left = None       # left sibling node (if val less than parent)
            self._right = None      # right sibling node (if val greater than parent)

    def __init__(self):
        """Binary Tree Constructor (creates an empty binary tree)"""
        self._root = None     # Binary tree root
        self._height = 0      # Number of values in the tree

    def get_root(self):
        return self._root

    def findMin(self, value):
        current = value
        while current._left:
            current = current._left
        return current


    def insert_element(self, value):
        """Method to insert an element into the BST"""
        if self._root is None:                         # if there is a root in the tree
            self._root = Binary_Search_Tree._BST_Node(value)   # create a new root equal to value
        else:
            self._insert_element(value, self._root)  # insert an element, calls recursive function
        self._height += 1



    def _insert_element(self, value, node):
        """Private method to Insert elements recursively"""
        #if node._value == value:  # if we come across a value already in the list
        #    raise ValueError
        if value < node._value:
            if node._left is not None:  # if a left node child node exists
                return self._insert_element(value, node._left)
                # call the insert element function again to evaluate next node
            else:
                node._left = Binary_Search_Tree._BST_Node(value)
                # after recursively crawling through the tree add value to left leaf
        else:
            if node._right is not None:
                return self._insert_element(value, node._right)
                # call the insert element function again to evaluate next node
            else:
                node._right = Binary_Search_Tree._BST_Node(value)
                # after recursively crawling through the tree add value to right leaf

    def remove_element(self, value):
        if self._root is None:
            print("There is nothing to remove")
        self._remove_element(value, self._root)

    def _remove_element(self, value, node):
        if node is None or node._value != value:
            print("Does not exist")
        #node with no children
        elif node._value == value:
            if node._left is None and node._right is None:
                return None
        #node with only only child
        elif node._left is None:
            print ("The node has no left child")
            return node._right
        elif node._right is None:
            print ("The node has no right child")
            return node._left
        else:
            node._value = get_min(node._right)
            self._(node._right, value)
        elif value < node._value:
            self._remove_element(node._left, value)
        else:
            self._right._remove_element(node._right, value)
        return node


    def in_order(self):
        # Construct and return a string representing the in-order
        # traversal of the tree. Empty trees should be printed as [ ].
        # Trees with one value should be printed in as [ 4 ]. Trees with
        # more than one value should be printed as [ 4, 7 ]. Note the spacing.
        # Your solution must be recursive. This will involve the introduction
        # of additional private methods to support the recursion control
        # variable.
        pass # TODO replace pass with your implementation

    def pre_order(self):
        # Construct an return a string representing the pre-order
        # traversal of the tree. Empty trees should be printed as [ ].
        # Trees with one value should be printed in as [ 4 ]. Trees with
        # more than one value should be printed as [ 4, 7 ]. Note the spacing.
        # Your solution must be recursive. This will involve the introduction
        # of additional private methods to support the recursion control
        # variable.
        pass # TODO replace pass with your implementation

    def post_order(self):
        # Construct an return a string representing the post-order
        # traversal of the tree. Empty trees should be printed as [ ].
        # Trees with one value should be printed in as [ 4 ]. Trees with
        # more than one value should be printed as [ 4, 7 ]. Note the spacing.
        # Your solution must be recursive. This will involve the introduction
        # of additional private methods to support the recursion control
        # variable.
        pass # TODO replace pass with your implementation

    def get_height(self):
        return self._height
        # return an integer that represents the height of the tree.
        # assume that an empty tree has height 0 and a tree with one
        # node has height 1. This method must operate in constant time.

    def __str__(self):
        return self.in_order()

    def print_tree(self):
        if self._root is not None:
            self._print_tree(self._root)

    def _print_tree(self, node):
        if node is not None:
            self._print_tree(node._left)
            print(str(node._value))
            self._print_tree(node._right)

if __name__ == '__main__':
    bst = Binary_Search_Tree()
    bst.insert_element(3)
    print(bst.get_height())
    bst.insert_element(2)
    bst.insert_element(4)
    bst.insert_element(5)
    #print(bst.find(2))
    print(bst.get_height())
    print(bst.print_tree())


